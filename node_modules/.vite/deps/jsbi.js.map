{
  "version": 3,
  "sources": ["../../jsbi/tsc-out/jsbi.mjs"],
  "sourcesContent": ["// Copyright 2018 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the “License”);\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// <https://apache.org/licenses/LICENSE-2.0>.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an “AS IS” BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass JSBI extends Array {\n    constructor(length, sign) {\n        super(length);\n        this.sign = sign;\n        // Explicitly set the prototype as per\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, JSBI.prototype);\n        if (length > JSBI.__kMaxLength) {\n            throw new RangeError('Maximum BigInt size exceeded');\n        }\n    }\n    static BigInt(arg) {\n        if (typeof arg === 'number') {\n            if (arg === 0)\n                return JSBI.__zero();\n            if (JSBI.__isOneDigitInt(arg)) {\n                if (arg < 0) {\n                    return JSBI.__oneDigit(-arg, true);\n                }\n                return JSBI.__oneDigit(arg, false);\n            }\n            if (!Number.isFinite(arg) || Math.floor(arg) !== arg) {\n                throw new RangeError('The number ' + arg + ' cannot be converted to ' +\n                    'BigInt because it is not an integer');\n            }\n            return JSBI.__fromDouble(arg);\n        }\n        else if (typeof arg === 'string') {\n            const result = JSBI.__fromString(arg);\n            if (result === null) {\n                throw new SyntaxError('Cannot convert ' + arg + ' to a BigInt');\n            }\n            return result;\n        }\n        else if (typeof arg === 'boolean') {\n            if (arg === true) {\n                return JSBI.__oneDigit(1, false);\n            }\n            return JSBI.__zero();\n        }\n        else if (typeof arg === 'object') {\n            if (arg.constructor === JSBI)\n                return arg;\n            const primitive = JSBI.__toPrimitive(arg);\n            return JSBI.BigInt(primitive);\n        }\n        throw new TypeError('Cannot convert ' + arg + ' to a BigInt');\n    }\n    toDebugString() {\n        const result = ['BigInt['];\n        for (const digit of this) {\n            result.push((digit ? (digit >>> 0).toString(16) : digit) + ', ');\n        }\n        result.push(']');\n        return result.join('');\n    }\n    toString(radix = 10) {\n        if (radix < 2 || radix > 36) {\n            throw new RangeError('toString() radix argument must be between 2 and 36');\n        }\n        if (this.length === 0)\n            return '0';\n        if ((radix & (radix - 1)) === 0) {\n            return JSBI.__toStringBasePowerOfTwo(this, radix);\n        }\n        return JSBI.__toStringGeneric(this, radix, false);\n    }\n    valueOf() {\n        throw new Error('Convert JSBI instances to native numbers using `toNumber`.');\n    }\n    // Equivalent of \"Number(my_bigint)\" in the native implementation.\n    // TODO: add more tests\n    static toNumber(x) {\n        const xLength = x.length;\n        if (xLength === 0)\n            return 0;\n        if (xLength === 1) {\n            const value = x.__unsignedDigit(0);\n            return x.sign ? -value : value;\n        }\n        const xMsd = x.__digit(xLength - 1);\n        const msdLeadingZeros = JSBI.__clz30(xMsd);\n        const xBitLength = xLength * 30 - msdLeadingZeros;\n        if (xBitLength > 1024)\n            return x.sign ? -Infinity : Infinity;\n        let exponent = xBitLength - 1;\n        let currentDigit = xMsd;\n        let digitIndex = xLength - 1;\n        const shift = msdLeadingZeros + 3;\n        let mantissaHigh = (shift === 32) ? 0 : currentDigit << shift;\n        mantissaHigh >>>= 12;\n        const mantissaHighBitsUnset = shift - 12;\n        let mantissaLow = (shift >= 12) ? 0 : (currentDigit << (20 + shift));\n        let mantissaLowBitsUnset = 20 + shift;\n        if (mantissaHighBitsUnset > 0 && digitIndex > 0) {\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            mantissaHigh |= (currentDigit >>> (30 - mantissaHighBitsUnset));\n            mantissaLow = currentDigit << mantissaHighBitsUnset + 2;\n            mantissaLowBitsUnset = mantissaHighBitsUnset + 2;\n        }\n        while (mantissaLowBitsUnset > 0 && digitIndex > 0) {\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            if (mantissaLowBitsUnset >= 30) {\n                mantissaLow |= (currentDigit << (mantissaLowBitsUnset - 30));\n            }\n            else {\n                mantissaLow |= (currentDigit >>> (30 - mantissaLowBitsUnset));\n            }\n            mantissaLowBitsUnset -= 30;\n        }\n        const rounding = JSBI.__decideRounding(x, mantissaLowBitsUnset, digitIndex, currentDigit);\n        if (rounding === 1 || (rounding === 0 && (mantissaLow & 1) === 1)) {\n            mantissaLow = (mantissaLow + 1) >>> 0;\n            if (mantissaLow === 0) {\n                // Incrementing mantissaLow overflowed.\n                mantissaHigh++;\n                if ((mantissaHigh >>> 20) !== 0) {\n                    // Incrementing mantissaHigh overflowed.\n                    mantissaHigh = 0;\n                    exponent++;\n                    if (exponent > 1023) {\n                        // Incrementing the exponent overflowed.\n                        return x.sign ? -Infinity : Infinity;\n                    }\n                }\n            }\n        }\n        const signBit = x.sign ? (1 << 31) : 0;\n        exponent = (exponent + 0x3FF) << 20;\n        JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] =\n            signBit | exponent | mantissaHigh;\n        JSBI.__kBitConversionInts[JSBI.__kBitConversionIntLow] = mantissaLow;\n        return JSBI.__kBitConversionDouble[0];\n    }\n    // Operations.\n    static unaryMinus(x) {\n        if (x.length === 0)\n            return x;\n        const result = x.__copy();\n        result.sign = !x.sign;\n        return result;\n    }\n    static bitwiseNot(x) {\n        if (x.sign) {\n            // ~(-x) == ~(~(x-1)) == x-1\n            return JSBI.__absoluteSubOne(x).__trim();\n        }\n        // ~x == -x-1 == -(x+1)\n        return JSBI.__absoluteAddOne(x, true);\n    }\n    static exponentiate(x, y) {\n        if (y.sign) {\n            throw new RangeError('Exponent must be positive');\n        }\n        if (y.length === 0) {\n            return JSBI.__oneDigit(1, false);\n        }\n        if (x.length === 0)\n            return x;\n        if (x.length === 1 && x.__digit(0) === 1) {\n            // (-1) ** even_number == 1.\n            if (x.sign && (y.__digit(0) & 1) === 0) {\n                return JSBI.unaryMinus(x);\n            }\n            // (-1) ** odd_number == -1, 1 ** anything == 1.\n            return x;\n        }\n        // For all bases >= 2, very large exponents would lead to unrepresentable\n        // results.\n        if (y.length > 1)\n            throw new RangeError('BigInt too big');\n        let expValue = y.__unsignedDigit(0);\n        if (expValue === 1)\n            return x;\n        if (expValue >= JSBI.__kMaxLengthBits) {\n            throw new RangeError('BigInt too big');\n        }\n        if (x.length === 1 && x.__digit(0) === 2) {\n            // Fast path for 2^n.\n            const neededDigits = 1 + ((expValue / 30) | 0);\n            const sign = x.sign && ((expValue & 1) !== 0);\n            const result = new JSBI(neededDigits, sign);\n            result.__initializeDigits();\n            // All bits are zero. Now set the n-th bit.\n            const msd = 1 << (expValue % 30);\n            result.__setDigit(neededDigits - 1, msd);\n            return result;\n        }\n        let result = null;\n        let runningSquare = x;\n        // This implicitly sets the result's sign correctly.\n        if ((expValue & 1) !== 0)\n            result = x;\n        expValue >>= 1;\n        for (; expValue !== 0; expValue >>= 1) {\n            runningSquare = JSBI.multiply(runningSquare, runningSquare);\n            if ((expValue & 1) !== 0) {\n                if (result === null) {\n                    result = runningSquare;\n                }\n                else {\n                    result = JSBI.multiply(result, runningSquare);\n                }\n            }\n        }\n        // TODO see if there's a way for tsc to infer this will always happen?\n        return result;\n    }\n    static multiply(x, y) {\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return y;\n        let resultLength = x.length + y.length;\n        if (x.__clzmsd() + y.__clzmsd() >= 30) {\n            resultLength--;\n        }\n        const result = new JSBI(resultLength, x.sign !== y.sign);\n        result.__initializeDigits();\n        for (let i = 0; i < x.length; i++) {\n            JSBI.__multiplyAccumulate(y, x.__digit(i), result, i);\n        }\n        return result.__trim();\n    }\n    static divide(x, y) {\n        if (y.length === 0)\n            throw new RangeError('Division by zero');\n        if (JSBI.__absoluteCompare(x, y) < 0)\n            return JSBI.__zero();\n        const resultSign = x.sign !== y.sign;\n        const divisor = y.__unsignedDigit(0);\n        let quotient;\n        if (y.length === 1 && divisor <= 0x7FFF) {\n            if (divisor === 1) {\n                return resultSign === x.sign ? x : JSBI.unaryMinus(x);\n            }\n            quotient = JSBI.__absoluteDivSmall(x, divisor, null);\n        }\n        else {\n            quotient = JSBI.__absoluteDivLarge(x, y, true, false);\n        }\n        quotient.sign = resultSign;\n        return quotient.__trim();\n    }\n    static remainder(x, y) {\n        if (y.length === 0)\n            throw new RangeError('Division by zero');\n        if (JSBI.__absoluteCompare(x, y) < 0)\n            return x;\n        const divisor = y.__unsignedDigit(0);\n        if (y.length === 1 && divisor <= 0x7FFF) {\n            if (divisor === 1)\n                return JSBI.__zero();\n            const remainderDigit = JSBI.__absoluteModSmall(x, divisor);\n            if (remainderDigit === 0)\n                return JSBI.__zero();\n            return JSBI.__oneDigit(remainderDigit, x.sign);\n        }\n        const remainder = JSBI.__absoluteDivLarge(x, y, false, true);\n        remainder.sign = x.sign;\n        return remainder.__trim();\n    }\n    static add(x, y) {\n        const sign = x.sign;\n        if (sign === y.sign) {\n            // x + y == x + y\n            // -x + -y == -(x + y)\n            return JSBI.__absoluteAdd(x, y, sign);\n        }\n        // x + -y == x - y == -(y - x)\n        // -x + y == y - x == -(x - y)\n        if (JSBI.__absoluteCompare(x, y) >= 0) {\n            return JSBI.__absoluteSub(x, y, sign);\n        }\n        return JSBI.__absoluteSub(y, x, !sign);\n    }\n    static subtract(x, y) {\n        const sign = x.sign;\n        if (sign !== y.sign) {\n            // x - (-y) == x + y\n            // (-x) - y == -(x + y)\n            return JSBI.__absoluteAdd(x, y, sign);\n        }\n        // x - y == -(y - x)\n        // (-x) - (-y) == y - x == -(x - y)\n        if (JSBI.__absoluteCompare(x, y) >= 0) {\n            return JSBI.__absoluteSub(x, y, sign);\n        }\n        return JSBI.__absoluteSub(y, x, !sign);\n    }\n    static leftShift(x, y) {\n        if (y.length === 0 || x.length === 0)\n            return x;\n        if (y.sign)\n            return JSBI.__rightShiftByAbsolute(x, y);\n        return JSBI.__leftShiftByAbsolute(x, y);\n    }\n    static signedRightShift(x, y) {\n        if (y.length === 0 || x.length === 0)\n            return x;\n        if (y.sign)\n            return JSBI.__leftShiftByAbsolute(x, y);\n        return JSBI.__rightShiftByAbsolute(x, y);\n    }\n    static unsignedRightShift() {\n        throw new TypeError('BigInts have no unsigned right shift; use >> instead');\n    }\n    static lessThan(x, y) {\n        return JSBI.__compareToBigInt(x, y) < 0;\n    }\n    static lessThanOrEqual(x, y) {\n        return JSBI.__compareToBigInt(x, y) <= 0;\n    }\n    static greaterThan(x, y) {\n        return JSBI.__compareToBigInt(x, y) > 0;\n    }\n    static greaterThanOrEqual(x, y) {\n        return JSBI.__compareToBigInt(x, y) >= 0;\n    }\n    static equal(x, y) {\n        if (x.sign !== y.sign)\n            return false;\n        if (x.length !== y.length)\n            return false;\n        for (let i = 0; i < x.length; i++) {\n            if (x.__digit(i) !== y.__digit(i))\n                return false;\n        }\n        return true;\n    }\n    static notEqual(x, y) {\n        return !JSBI.equal(x, y);\n    }\n    static bitwiseAnd(x, y) {\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteAnd(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            const resultLength = Math.max(x.length, y.length) + 1;\n            // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))\n            // == -(((x-1) | (y-1)) + 1)\n            let result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            result = JSBI.__absoluteOr(result, y1, result);\n            return JSBI.__absoluteAddOne(result, true, result).__trim();\n        }\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x & (-y) == x & ~(y-1) == x &~ (y-1)\n        return JSBI.__absoluteAndNot(x, JSBI.__absoluteSubOne(y)).__trim();\n    }\n    static bitwiseXor(x, y) {\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteXor(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)\n            const resultLength = Math.max(x.length, y.length);\n            const result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            return JSBI.__absoluteXor(result, y1, result).__trim();\n        }\n        const resultLength = Math.max(x.length, y.length) + 1;\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)\n        let result = JSBI.__absoluteSubOne(y, resultLength);\n        result = JSBI.__absoluteXor(result, x, result);\n        return JSBI.__absoluteAddOne(result, true, result).__trim();\n    }\n    static bitwiseOr(x, y) {\n        const resultLength = Math.max(x.length, y.length);\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteOr(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))\n            // == -(((x-1) & (y-1)) + 1)\n            let result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            result = JSBI.__absoluteAnd(result, y1, result);\n            return JSBI.__absoluteAddOne(result, true, result).__trim();\n        }\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) ~& x) + 1)\n        let result = JSBI.__absoluteSubOne(y, resultLength);\n        result = JSBI.__absoluteAndNot(result, x, result);\n        return JSBI.__absoluteAddOne(result, true, result).__trim();\n    }\n    static asIntN(n, x) {\n        if (x.length === 0)\n            return x;\n        n = Math.floor(n);\n        if (n < 0) {\n            throw new RangeError('Invalid value: not (convertible to) a safe integer');\n        }\n        if (n === 0)\n            return JSBI.__zero();\n        // If {x} has less than {n} bits, return it directly.\n        if (n >= JSBI.__kMaxLengthBits)\n            return x;\n        const neededLength = ((n + 29) / 30) | 0;\n        if (x.length < neededLength)\n            return x;\n        const topDigit = x.__unsignedDigit(neededLength - 1);\n        const compareDigit = 1 << ((n - 1) % 30);\n        if (x.length === neededLength && topDigit < compareDigit)\n            return x;\n        // Otherwise truncate and simulate two's complement.\n        const hasBit = (topDigit & compareDigit) === compareDigit;\n        if (!hasBit)\n            return JSBI.__truncateToNBits(n, x);\n        if (!x.sign)\n            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, true);\n        if ((topDigit & (compareDigit - 1)) === 0) {\n            for (let i = neededLength - 2; i >= 0; i--) {\n                if (x.__digit(i) !== 0) {\n                    return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n                }\n            }\n            if (x.length === neededLength && topDigit === compareDigit)\n                return x;\n            return JSBI.__truncateToNBits(n, x);\n        }\n        return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n    }\n    static asUintN(n, x) {\n        if (x.length === 0)\n            return x;\n        n = Math.floor(n);\n        if (n < 0) {\n            throw new RangeError('Invalid value: not (convertible to) a safe integer');\n        }\n        if (n === 0)\n            return JSBI.__zero();\n        // If {x} is negative, simulate two's complement representation.\n        if (x.sign) {\n            if (n > JSBI.__kMaxLengthBits) {\n                throw new RangeError('BigInt too big');\n            }\n            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n        }\n        // If {x} is positive and has up to {n} bits, return it directly.\n        if (n >= JSBI.__kMaxLengthBits)\n            return x;\n        const neededLength = ((n + 29) / 30) | 0;\n        if (x.length < neededLength)\n            return x;\n        const bitsInTopDigit = n % 30;\n        if (x.length == neededLength) {\n            if (bitsInTopDigit === 0)\n                return x;\n            const topDigit = x.__digit(neededLength - 1);\n            if ((topDigit >>> bitsInTopDigit) === 0)\n                return x;\n        }\n        // Otherwise, truncate.\n        return JSBI.__truncateToNBits(n, x);\n    }\n    // Operators.\n    static ADD(x, y) {\n        x = JSBI.__toPrimitive(x);\n        y = JSBI.__toPrimitive(y);\n        if (typeof x === 'string') {\n            if (typeof y !== 'string')\n                y = y.toString();\n            return x + y;\n        }\n        if (typeof y === 'string') {\n            return x.toString() + y;\n        }\n        x = JSBI.__toNumeric(x);\n        y = JSBI.__toNumeric(y);\n        if (JSBI.__isBigInt(x) && JSBI.__isBigInt(y)) {\n            return JSBI.add(x, y);\n        }\n        if (typeof x === 'number' && typeof y === 'number') {\n            return x + y;\n        }\n        throw new TypeError('Cannot mix BigInt and other types, use explicit conversions');\n    }\n    static LT(x, y) {\n        return JSBI.__compare(x, y, 0);\n    }\n    static LE(x, y) {\n        return JSBI.__compare(x, y, 1);\n    }\n    static GT(x, y) {\n        return JSBI.__compare(x, y, 2);\n    }\n    static GE(x, y) {\n        return JSBI.__compare(x, y, 3);\n    }\n    static EQ(x, y) {\n        while (true) {\n            if (JSBI.__isBigInt(x)) {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.equal(x, y);\n                return JSBI.EQ(y, x);\n            }\n            else if (typeof x === 'number') {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.__equalToNumber(y, x);\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'string') {\n                if (JSBI.__isBigInt(y)) {\n                    x = JSBI.__fromString(x);\n                    if (x === null)\n                        return false;\n                    return JSBI.equal(x, y);\n                }\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'boolean') {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.__equalToNumber(y, +x);\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'symbol') {\n                if (JSBI.__isBigInt(y))\n                    return false;\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'object') {\n                if (typeof y === 'object' && y.constructor !== JSBI)\n                    return x == y;\n                x = JSBI.__toPrimitive(x);\n            }\n            else {\n                return x == y;\n            }\n        }\n    }\n    static NE(x, y) {\n        return !JSBI.EQ(x, y);\n    }\n    // DataView-related functionality.\n    static DataViewGetBigInt64(dataview, byteOffset, littleEndian = false) {\n        return JSBI.asIntN(64, JSBI.DataViewGetBigUint64(dataview, byteOffset, littleEndian));\n    }\n    static DataViewGetBigUint64(dataview, byteOffset, littleEndian = false) {\n        const [h, l] = littleEndian ? [4, 0] : [0, 4];\n        const high = dataview.getUint32(byteOffset + h, littleEndian);\n        const low = dataview.getUint32(byteOffset + l, littleEndian);\n        const result = new JSBI(3, false);\n        result.__setDigit(0, low & 0x3FFFFFFF);\n        result.__setDigit(1, ((high & 0xFFFFFFF) << 2) | (low >>> 30));\n        result.__setDigit(2, high >>> 28);\n        return result.__trim();\n    }\n    static DataViewSetBigInt64(dataview, byteOffset, value, littleEndian = false) {\n        JSBI.DataViewSetBigUint64(dataview, byteOffset, value, littleEndian);\n    }\n    static DataViewSetBigUint64(dataview, byteOffset, value, littleEndian = false) {\n        value = JSBI.asUintN(64, value);\n        let high = 0;\n        let low = 0;\n        if (value.length > 0) {\n            low = value.__digit(0);\n            if (value.length > 1) {\n                const d1 = value.__digit(1);\n                low = low | d1 << 30;\n                high = d1 >>> 2;\n                if (value.length > 2) {\n                    high = high | (value.__digit(2) << 28);\n                }\n            }\n        }\n        const [h, l] = littleEndian ? [4, 0] : [0, 4];\n        dataview.setUint32(byteOffset + h, high, littleEndian);\n        dataview.setUint32(byteOffset + l, low, littleEndian);\n    }\n    // Helpers.\n    static __zero() {\n        return new JSBI(0, false);\n    }\n    static __oneDigit(value, sign) {\n        const result = new JSBI(1, sign);\n        result.__setDigit(0, value);\n        return result;\n    }\n    __copy() {\n        const result = new JSBI(this.length, this.sign);\n        for (let i = 0; i < this.length; i++) {\n            result[i] = this[i];\n        }\n        return result;\n    }\n    __trim() {\n        let newLength = this.length;\n        let last = this[newLength - 1];\n        while (last === 0) {\n            newLength--;\n            last = this[newLength - 1];\n            this.pop();\n        }\n        if (newLength === 0)\n            this.sign = false;\n        return this;\n    }\n    __initializeDigits() {\n        for (let i = 0; i < this.length; i++) {\n            this[i] = 0;\n        }\n    }\n    static __decideRounding(x, mantissaBitsUnset, digitIndex, currentDigit) {\n        if (mantissaBitsUnset > 0)\n            return -1;\n        let topUnconsumedBit;\n        if (mantissaBitsUnset < 0) {\n            topUnconsumedBit = -mantissaBitsUnset - 1;\n        }\n        else {\n            // {currentDigit} fit the mantissa exactly; look at the next digit.\n            if (digitIndex === 0)\n                return -1;\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            topUnconsumedBit = 29;\n        }\n        // If the most significant remaining bit is 0, round down.\n        let mask = 1 << topUnconsumedBit;\n        if ((currentDigit & mask) === 0)\n            return -1;\n        // If any other remaining bit is set, round up.\n        mask -= 1;\n        if ((currentDigit & mask) !== 0)\n            return 1;\n        while (digitIndex > 0) {\n            digitIndex--;\n            if (x.__digit(digitIndex) !== 0)\n                return 1;\n        }\n        return 0;\n    }\n    static __fromDouble(value) {\n        const sign = value < 0;\n        JSBI.__kBitConversionDouble[0] = value;\n        const rawExponent = (JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] >>> 20) &\n            0x7FF;\n        const exponent = rawExponent - 0x3FF;\n        const digits = ((exponent / 30) | 0) + 1;\n        const result = new JSBI(digits, sign);\n        const kHiddenBit = 0x00100000;\n        let mantissaHigh = (JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] & 0xFFFFF) |\n            kHiddenBit;\n        let mantissaLow = JSBI.__kBitConversionInts[JSBI.__kBitConversionIntLow];\n        const kMantissaHighTopBit = 20;\n        // 0-indexed position of most significant bit in most significant digit.\n        const msdTopBit = exponent % 30;\n        // Number of unused bits in the mantissa. We'll keep them shifted to the\n        // left (i.e. most significant part).\n        let remainingMantissaBits = 0;\n        // Next digit under construction.\n        let digit;\n        // First, build the MSD by shifting the mantissa appropriately.\n        if (msdTopBit < kMantissaHighTopBit) {\n            const shift = kMantissaHighTopBit - msdTopBit;\n            remainingMantissaBits = shift + 32;\n            digit = mantissaHigh >>> shift;\n            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);\n            mantissaLow = mantissaLow << (32 - shift);\n        }\n        else if (msdTopBit === kMantissaHighTopBit) {\n            remainingMantissaBits = 32;\n            digit = mantissaHigh;\n            mantissaHigh = mantissaLow;\n            mantissaLow = 0;\n        }\n        else {\n            const shift = msdTopBit - kMantissaHighTopBit;\n            remainingMantissaBits = 32 - shift;\n            digit = (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));\n            mantissaHigh = mantissaLow << shift;\n            mantissaLow = 0;\n        }\n        result.__setDigit(digits - 1, digit);\n        // Then fill in the rest of the digits.\n        for (let digitIndex = digits - 2; digitIndex >= 0; digitIndex--) {\n            if (remainingMantissaBits > 0) {\n                remainingMantissaBits -= 30;\n                digit = mantissaHigh >>> 2;\n                mantissaHigh = (mantissaHigh << 30) | (mantissaLow >>> 2);\n                mantissaLow = (mantissaLow << 30);\n            }\n            else {\n                digit = 0;\n            }\n            result.__setDigit(digitIndex, digit);\n        }\n        return result.__trim();\n    }\n    static __isWhitespace(c) {\n        if (c <= 0x0D && c >= 0x09)\n            return true;\n        if (c <= 0x9F)\n            return c === 0x20;\n        if (c <= 0x01FFFF) {\n            return c === 0xA0 || c === 0x1680;\n        }\n        if (c <= 0x02FFFF) {\n            c &= 0x01FFFF;\n            return c <= 0x0A || c === 0x28 || c === 0x29 || c === 0x2F ||\n                c === 0x5F || c === 0x1000;\n        }\n        return c === 0xFEFF;\n    }\n    static __fromString(string, radix = 0) {\n        let sign = 0;\n        let leadingZero = false;\n        const length = string.length;\n        let cursor = 0;\n        if (cursor === length)\n            return JSBI.__zero();\n        let current = string.charCodeAt(cursor);\n        // Skip whitespace.\n        while (JSBI.__isWhitespace(current)) {\n            if (++cursor === length)\n                return JSBI.__zero();\n            current = string.charCodeAt(cursor);\n        }\n        // Detect radix.\n        if (current === 0x2B) { // '+'\n            if (++cursor === length)\n                return null;\n            current = string.charCodeAt(cursor);\n            sign = 1;\n        }\n        else if (current === 0x2D) { // '-'\n            if (++cursor === length)\n                return null;\n            current = string.charCodeAt(cursor);\n            sign = -1;\n        }\n        if (radix === 0) {\n            radix = 10;\n            if (current === 0x30) { // '0'\n                if (++cursor === length)\n                    return JSBI.__zero();\n                current = string.charCodeAt(cursor);\n                if (current === 0x58 || current === 0x78) { // 'X' or 'x'\n                    radix = 16;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else if (current === 0x4F || current === 0x6F) { // 'O' or 'o'\n                    radix = 8;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else if (current === 0x42 || current === 0x62) { // 'B' or 'b'\n                    radix = 2;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else {\n                    leadingZero = true;\n                }\n            }\n        }\n        else if (radix === 16) {\n            if (current === 0x30) { // '0'\n                // Allow \"0x\" prefix.\n                if (++cursor === length)\n                    return JSBI.__zero();\n                current = string.charCodeAt(cursor);\n                if (current === 0x58 || current === 0x78) { // 'X' or 'x'\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else {\n                    leadingZero = true;\n                }\n            }\n        }\n        if (sign !== 0 && radix !== 10)\n            return null;\n        // Skip leading zeros.\n        while (current === 0x30) {\n            leadingZero = true;\n            if (++cursor === length)\n                return JSBI.__zero();\n            current = string.charCodeAt(cursor);\n        }\n        // Allocate result.\n        const chars = length - cursor;\n        let bitsPerChar = JSBI.__kMaxBitsPerChar[radix];\n        let roundup = JSBI.__kBitsPerCharTableMultiplier - 1;\n        if (chars > (1 << 30) / bitsPerChar)\n            return null;\n        const bitsMin = (bitsPerChar * chars + roundup) >>> JSBI.__kBitsPerCharTableShift;\n        const resultLength = ((bitsMin + 29) / 30) | 0;\n        const result = new JSBI(resultLength, false);\n        // Parse.\n        const limDigit = radix < 10 ? radix : 10;\n        const limAlpha = radix > 10 ? radix - 10 : 0;\n        if ((radix & (radix - 1)) === 0) {\n            // Power-of-two radix.\n            bitsPerChar >>= JSBI.__kBitsPerCharTableShift;\n            const parts = [];\n            const partsBits = [];\n            let done = false;\n            do {\n                let part = 0;\n                let bits = 0;\n                while (true) {\n                    let d;\n                    if (((current - 48) >>> 0) < limDigit) {\n                        d = current - 48;\n                    }\n                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {\n                        d = (current | 32) - 87;\n                    }\n                    else {\n                        done = true;\n                        break;\n                    }\n                    bits += bitsPerChar;\n                    part = (part << bitsPerChar) | d;\n                    if (++cursor === length) {\n                        done = true;\n                        break;\n                    }\n                    current = string.charCodeAt(cursor);\n                    if (bits + bitsPerChar > 30)\n                        break;\n                }\n                parts.push(part);\n                partsBits.push(bits);\n            } while (!done);\n            JSBI.__fillFromParts(result, parts, partsBits);\n        }\n        else {\n            result.__initializeDigits();\n            let done = false;\n            let charsSoFar = 0;\n            do {\n                let part = 0;\n                let multiplier = 1;\n                while (true) {\n                    let d;\n                    if (((current - 48) >>> 0) < limDigit) {\n                        d = current - 48;\n                    }\n                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {\n                        d = (current | 32) - 87;\n                    }\n                    else {\n                        done = true;\n                        break;\n                    }\n                    const m = multiplier * radix;\n                    if (m > 0x3FFFFFFF)\n                        break;\n                    multiplier = m;\n                    part = part * radix + d;\n                    charsSoFar++;\n                    if (++cursor === length) {\n                        done = true;\n                        break;\n                    }\n                    current = string.charCodeAt(cursor);\n                }\n                roundup = JSBI.__kBitsPerCharTableMultiplier * 30 - 1;\n                const digitsSoFar = (((bitsPerChar * charsSoFar + roundup) >>>\n                    JSBI.__kBitsPerCharTableShift) / 30) | 0;\n                result.__inplaceMultiplyAdd(multiplier, part, digitsSoFar);\n            } while (!done);\n        }\n        if (cursor !== length) {\n            if (!JSBI.__isWhitespace(current))\n                return null;\n            for (cursor++; cursor < length; cursor++) {\n                current = string.charCodeAt(cursor);\n                if (!JSBI.__isWhitespace(current))\n                    return null;\n            }\n        }\n        // Get result.\n        result.sign = (sign === -1);\n        return result.__trim();\n    }\n    static __fillFromParts(result, parts, partsBits) {\n        let digitIndex = 0;\n        let digit = 0;\n        let bitsInDigit = 0;\n        for (let i = parts.length - 1; i >= 0; i--) {\n            const part = parts[i];\n            const partBits = partsBits[i];\n            digit |= (part << bitsInDigit);\n            bitsInDigit += partBits;\n            if (bitsInDigit === 30) {\n                result.__setDigit(digitIndex++, digit);\n                bitsInDigit = 0;\n                digit = 0;\n            }\n            else if (bitsInDigit > 30) {\n                result.__setDigit(digitIndex++, digit & 0x3FFFFFFF);\n                bitsInDigit -= 30;\n                digit = part >>> (partBits - bitsInDigit);\n            }\n        }\n        if (digit !== 0) {\n            if (digitIndex >= result.length)\n                throw new Error('implementation bug');\n            result.__setDigit(digitIndex++, digit);\n        }\n        for (; digitIndex < result.length; digitIndex++) {\n            result.__setDigit(digitIndex, 0);\n        }\n    }\n    static __toStringBasePowerOfTwo(x, radix) {\n        const length = x.length;\n        let bits = radix - 1;\n        bits = ((bits >>> 1) & 0x55) + (bits & 0x55);\n        bits = ((bits >>> 2) & 0x33) + (bits & 0x33);\n        bits = ((bits >>> 4) & 0x0F) + (bits & 0x0F);\n        const bitsPerChar = bits;\n        const charMask = radix - 1;\n        const msd = x.__digit(length - 1);\n        const msdLeadingZeros = JSBI.__clz30(msd);\n        const bitLength = length * 30 - msdLeadingZeros;\n        let charsRequired = ((bitLength + bitsPerChar - 1) / bitsPerChar) | 0;\n        if (x.sign)\n            charsRequired++;\n        if (charsRequired > (1 << 28))\n            throw new Error('string too long');\n        const result = new Array(charsRequired);\n        let pos = charsRequired - 1;\n        let digit = 0;\n        let availableBits = 0;\n        for (let i = 0; i < length - 1; i++) {\n            const newDigit = x.__digit(i);\n            const current = (digit | (newDigit << availableBits)) & charMask;\n            result[pos--] = JSBI.__kConversionChars[current];\n            const consumedBits = bitsPerChar - availableBits;\n            digit = newDigit >>> consumedBits;\n            availableBits = 30 - consumedBits;\n            while (availableBits >= bitsPerChar) {\n                result[pos--] = JSBI.__kConversionChars[digit & charMask];\n                digit >>>= bitsPerChar;\n                availableBits -= bitsPerChar;\n            }\n        }\n        const current = (digit | (msd << availableBits)) & charMask;\n        result[pos--] = JSBI.__kConversionChars[current];\n        digit = msd >>> (bitsPerChar - availableBits);\n        while (digit !== 0) {\n            result[pos--] = JSBI.__kConversionChars[digit & charMask];\n            digit >>>= bitsPerChar;\n        }\n        if (x.sign)\n            result[pos--] = '-';\n        if (pos !== -1)\n            throw new Error('implementation bug');\n        return result.join('');\n    }\n    static __toStringGeneric(x, radix, isRecursiveCall) {\n        const length = x.length;\n        if (length === 0)\n            return '';\n        if (length === 1) {\n            let result = x.__unsignedDigit(0).toString(radix);\n            if (isRecursiveCall === false && x.sign) {\n                result = '-' + result;\n            }\n            return result;\n        }\n        const bitLength = length * 30 - JSBI.__clz30(x.__digit(length - 1));\n        const maxBitsPerChar = JSBI.__kMaxBitsPerChar[radix];\n        const minBitsPerChar = maxBitsPerChar - 1;\n        let charsRequired = bitLength * JSBI.__kBitsPerCharTableMultiplier;\n        charsRequired += minBitsPerChar - 1;\n        charsRequired = (charsRequired / minBitsPerChar) | 0;\n        const secondHalfChars = (charsRequired + 1) >> 1;\n        // Divide-and-conquer: split by a power of {radix} that's approximately\n        // the square root of {x}, then recurse.\n        const conqueror = JSBI.exponentiate(JSBI.__oneDigit(radix, false), JSBI.__oneDigit(secondHalfChars, false));\n        let quotient;\n        let secondHalf;\n        const divisor = conqueror.__unsignedDigit(0);\n        if (conqueror.length === 1 && divisor <= 0x7FFF) {\n            quotient = new JSBI(x.length, false);\n            quotient.__initializeDigits();\n            let remainder = 0;\n            for (let i = x.length * 2 - 1; i >= 0; i--) {\n                const input = (remainder << 15) | x.__halfDigit(i);\n                quotient.__setHalfDigit(i, (input / divisor) | 0);\n                remainder = (input % divisor) | 0;\n            }\n            secondHalf = remainder.toString(radix);\n        }\n        else {\n            const divisionResult = JSBI.__absoluteDivLarge(x, conqueror, true, true);\n            quotient = divisionResult.quotient;\n            const remainder = divisionResult.remainder.__trim();\n            secondHalf = JSBI.__toStringGeneric(remainder, radix, true);\n        }\n        quotient.__trim();\n        let firstHalf = JSBI.__toStringGeneric(quotient, radix, true);\n        while (secondHalf.length < secondHalfChars) {\n            secondHalf = '0' + secondHalf;\n        }\n        if (isRecursiveCall === false && x.sign) {\n            firstHalf = '-' + firstHalf;\n        }\n        return firstHalf + secondHalf;\n    }\n    static __unequalSign(leftNegative) {\n        return leftNegative ? -1 : 1;\n    }\n    static __absoluteGreater(bothNegative) {\n        return bothNegative ? -1 : 1;\n    }\n    static __absoluteLess(bothNegative) {\n        return bothNegative ? 1 : -1;\n    }\n    static __compareToBigInt(x, y) {\n        const xSign = x.sign;\n        if (xSign !== y.sign)\n            return JSBI.__unequalSign(xSign);\n        const result = JSBI.__absoluteCompare(x, y);\n        if (result > 0)\n            return JSBI.__absoluteGreater(xSign);\n        if (result < 0)\n            return JSBI.__absoluteLess(xSign);\n        return 0;\n    }\n    static __compareToNumber(x, y) {\n        if (JSBI.__isOneDigitInt(y)) {\n            const xSign = x.sign;\n            const ySign = (y < 0);\n            if (xSign !== ySign)\n                return JSBI.__unequalSign(xSign);\n            if (x.length === 0) {\n                if (ySign)\n                    throw new Error('implementation bug');\n                return y === 0 ? 0 : -1;\n            }\n            // Any multi-digit BigInt is bigger than an int32.\n            if (x.length > 1)\n                return JSBI.__absoluteGreater(xSign);\n            const yAbs = Math.abs(y);\n            const xDigit = x.__unsignedDigit(0);\n            if (xDigit > yAbs)\n                return JSBI.__absoluteGreater(xSign);\n            if (xDigit < yAbs)\n                return JSBI.__absoluteLess(xSign);\n            return 0;\n        }\n        return JSBI.__compareToDouble(x, y);\n    }\n    static __compareToDouble(x, y) {\n        if (y !== y)\n            return y; // NaN.\n        if (y === Infinity)\n            return -1;\n        if (y === -Infinity)\n            return 1;\n        const xSign = x.sign;\n        const ySign = (y < 0);\n        if (xSign !== ySign)\n            return JSBI.__unequalSign(xSign);\n        if (y === 0) {\n            throw new Error('implementation bug: should be handled elsewhere');\n        }\n        if (x.length === 0)\n            return -1;\n        JSBI.__kBitConversionDouble[0] = y;\n        const rawExponent = (JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] >>> 20) &\n            0x7FF;\n        if (rawExponent === 0x7FF) {\n            throw new Error('implementation bug: handled elsewhere');\n        }\n        const exponent = rawExponent - 0x3FF;\n        if (exponent < 0) {\n            // The absolute value of y is less than 1. Only 0n has an absolute\n            // value smaller than that, but we've already covered that case.\n            return JSBI.__absoluteGreater(xSign);\n        }\n        const xLength = x.length;\n        let xMsd = x.__digit(xLength - 1);\n        const msdLeadingZeros = JSBI.__clz30(xMsd);\n        const xBitLength = xLength * 30 - msdLeadingZeros;\n        const yBitLength = exponent + 1;\n        if (xBitLength < yBitLength)\n            return JSBI.__absoluteLess(xSign);\n        if (xBitLength > yBitLength)\n            return JSBI.__absoluteGreater(xSign);\n        // Same sign, same bit length. Shift mantissa to align with x and compare\n        // bit for bit.\n        const kHiddenBit = 0x00100000;\n        let mantissaHigh = (JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] & 0xFFFFF) |\n            kHiddenBit;\n        let mantissaLow = JSBI.__kBitConversionInts[JSBI.__kBitConversionIntLow];\n        const kMantissaHighTopBit = 20;\n        const msdTopBit = 29 - msdLeadingZeros;\n        if (msdTopBit !== (((xBitLength - 1) % 30) | 0)) {\n            throw new Error('implementation bug');\n        }\n        let compareMantissa; // Shifted chunk of mantissa.\n        let remainingMantissaBits = 0;\n        // First, compare most significant digit against beginning of mantissa.\n        if (msdTopBit < kMantissaHighTopBit) {\n            const shift = kMantissaHighTopBit - msdTopBit;\n            remainingMantissaBits = shift + 32;\n            compareMantissa = mantissaHigh >>> shift;\n            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);\n            mantissaLow = mantissaLow << (32 - shift);\n        }\n        else if (msdTopBit === kMantissaHighTopBit) {\n            remainingMantissaBits = 32;\n            compareMantissa = mantissaHigh;\n            mantissaHigh = mantissaLow;\n            mantissaLow = 0;\n        }\n        else {\n            const shift = msdTopBit - kMantissaHighTopBit;\n            remainingMantissaBits = 32 - shift;\n            compareMantissa =\n                (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));\n            mantissaHigh = mantissaLow << shift;\n            mantissaLow = 0;\n        }\n        xMsd = xMsd >>> 0;\n        compareMantissa = compareMantissa >>> 0;\n        if (xMsd > compareMantissa)\n            return JSBI.__absoluteGreater(xSign);\n        if (xMsd < compareMantissa)\n            return JSBI.__absoluteLess(xSign);\n        // Then, compare additional digits against remaining mantissa bits.\n        for (let digitIndex = xLength - 2; digitIndex >= 0; digitIndex--) {\n            if (remainingMantissaBits > 0) {\n                remainingMantissaBits -= 30;\n                compareMantissa = mantissaHigh >>> 2;\n                mantissaHigh = (mantissaHigh << 30) | (mantissaLow >>> 2);\n                mantissaLow = (mantissaLow << 30);\n            }\n            else {\n                compareMantissa = 0;\n            }\n            const digit = x.__unsignedDigit(digitIndex);\n            if (digit > compareMantissa)\n                return JSBI.__absoluteGreater(xSign);\n            if (digit < compareMantissa)\n                return JSBI.__absoluteLess(xSign);\n        }\n        // Integer parts are equal; check whether {y} has a fractional part.\n        if (mantissaHigh !== 0 || mantissaLow !== 0) {\n            if (remainingMantissaBits === 0)\n                throw new Error('implementation bug');\n            return JSBI.__absoluteLess(xSign);\n        }\n        return 0;\n    }\n    static __equalToNumber(x, y) {\n        if (JSBI.__isOneDigitInt(y)) {\n            if (y === 0)\n                return x.length === 0;\n            // Any multi-digit BigInt is bigger than an int32.\n            return (x.length === 1) && (x.sign === (y < 0)) &&\n                (x.__unsignedDigit(0) === Math.abs(y));\n        }\n        return JSBI.__compareToDouble(x, y) === 0;\n    }\n    // Comparison operations, chosen such that \"op ^ 2\" reverses direction:\n    // 0 - lessThan\n    // 1 - lessThanOrEqual\n    // 2 - greaterThan\n    // 3 - greaterThanOrEqual\n    static __comparisonResultToBool(result, op) {\n        switch (op) {\n            case 0: return result < 0;\n            case 1: return result <= 0;\n            case 2: return result > 0;\n            case 3: return result >= 0;\n        }\n    }\n    static __compare(x, y, op) {\n        x = JSBI.__toPrimitive(x);\n        y = JSBI.__toPrimitive(y);\n        if (typeof x === 'string' && typeof y === 'string') {\n            switch (op) {\n                case 0: return x < y;\n                case 1: return x <= y;\n                case 2: return x > y;\n                case 3: return x >= y;\n            }\n        }\n        if (JSBI.__isBigInt(x) && typeof y === 'string') {\n            y = JSBI.__fromString(y);\n            if (y === null)\n                return false;\n            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n        }\n        if (typeof x === 'string' && JSBI.__isBigInt(y)) {\n            x = JSBI.__fromString(x);\n            if (x === null)\n                return false;\n            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n        }\n        x = JSBI.__toNumeric(x);\n        y = JSBI.__toNumeric(y);\n        if (JSBI.__isBigInt(x)) {\n            if (JSBI.__isBigInt(y)) {\n                return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n            }\n            if (typeof y !== 'number')\n                throw new Error('implementation bug');\n            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(x, y), op);\n        }\n        if (typeof x !== 'number')\n            throw new Error('implementation bug');\n        if (JSBI.__isBigInt(y)) {\n            // Note that \"op ^ 2\" reverses the op's direction.\n            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(y, x), (op ^ 2));\n        }\n        if (typeof y !== 'number')\n            throw new Error('implementation bug');\n        switch (op) {\n            case 0: return x < y;\n            case 1: return x <= y;\n            case 2: return x > y;\n            case 3: return x >= y;\n        }\n    }\n    __clzmsd() {\n        return JSBI.__clz30(this.__digit(this.length - 1));\n    }\n    static __absoluteAdd(x, y, resultSign) {\n        if (x.length < y.length)\n            return JSBI.__absoluteAdd(y, x, resultSign);\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return x.sign === resultSign ? x : JSBI.unaryMinus(x);\n        let resultLength = x.length;\n        if (x.__clzmsd() === 0 || (y.length === x.length && y.__clzmsd() === 0)) {\n            resultLength++;\n        }\n        const result = new JSBI(resultLength, resultSign);\n        let carry = 0;\n        let i = 0;\n        for (; i < y.length; i++) {\n            const r = x.__digit(i) + y.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < x.length; i++) {\n            const r = x.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (i < result.length) {\n            result.__setDigit(i, carry);\n        }\n        return result.__trim();\n    }\n    static __absoluteSub(x, y, resultSign) {\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return x.sign === resultSign ? x : JSBI.unaryMinus(x);\n        const result = new JSBI(x.length, resultSign);\n        let borrow = 0;\n        let i = 0;\n        for (; i < y.length; i++) {\n            const r = x.__digit(i) - y.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < x.length; i++) {\n            const r = x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        return result.__trim();\n    }\n    static __absoluteAddOne(x, sign, result = null) {\n        const inputLength = x.length;\n        if (result === null) {\n            result = new JSBI(inputLength, sign);\n        }\n        else {\n            result.sign = sign;\n        }\n        let carry = 1;\n        for (let i = 0; i < inputLength; i++) {\n            const r = x.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (carry !== 0) {\n            result.__setDigitGrow(inputLength, 1);\n        }\n        return result;\n    }\n    static __absoluteSubOne(x, resultLength) {\n        const length = x.length;\n        resultLength = resultLength || length;\n        const result = new JSBI(resultLength, false);\n        let borrow = 1;\n        for (let i = 0; i < length; i++) {\n            const r = x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (borrow !== 0)\n            throw new Error('implementation bug');\n        for (let i = length; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteAnd(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = numPairs;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) & y.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteAndNot(x, y, result = null) {\n        const xLength = x.length;\n        const yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) & ~y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteOr(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) | y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteXor(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) ^ y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteCompare(x, y) {\n        const diff = x.length - y.length;\n        if (diff !== 0)\n            return diff;\n        let i = x.length - 1;\n        while (i >= 0 && x.__digit(i) === y.__digit(i))\n            i--;\n        if (i < 0)\n            return 0;\n        return x.__unsignedDigit(i) > y.__unsignedDigit(i) ? 1 : -1;\n    }\n    static __multiplyAccumulate(multiplicand, multiplier, accumulator, accumulatorIndex) {\n        if (multiplier === 0)\n            return;\n        const m2Low = multiplier & 0x7FFF;\n        const m2High = multiplier >>> 15;\n        let carry = 0;\n        let high = 0;\n        for (let i = 0; i < multiplicand.length; i++, accumulatorIndex++) {\n            let acc = accumulator.__digit(accumulatorIndex);\n            const m1 = multiplicand.__digit(i);\n            const m1Low = m1 & 0x7FFF;\n            const m1High = m1 >>> 15;\n            const rLow = JSBI.__imul(m1Low, m2Low);\n            const rMid1 = JSBI.__imul(m1Low, m2High);\n            const rMid2 = JSBI.__imul(m1High, m2Low);\n            const rHigh = JSBI.__imul(m1High, m2High);\n            acc += high + rLow + carry;\n            carry = acc >>> 30;\n            acc &= 0x3FFFFFFF;\n            acc += ((rMid1 & 0x7FFF) << 15) + ((rMid2 & 0x7FFF) << 15);\n            carry += acc >>> 30;\n            high = rHigh + (rMid1 >>> 15) + (rMid2 >>> 15);\n            accumulator.__setDigit(accumulatorIndex, acc & 0x3FFFFFFF);\n        }\n        for (; carry !== 0 || high !== 0; accumulatorIndex++) {\n            let acc = accumulator.__digit(accumulatorIndex);\n            acc += carry + high;\n            high = 0;\n            carry = acc >>> 30;\n            accumulator.__setDigit(accumulatorIndex, acc & 0x3FFFFFFF);\n        }\n    }\n    static __internalMultiplyAdd(source, factor, summand, n, result) {\n        let carry = summand;\n        let high = 0;\n        for (let i = 0; i < n; i++) {\n            const digit = source.__digit(i);\n            const rx = JSBI.__imul(digit & 0x7FFF, factor);\n            const ry = JSBI.__imul(digit >>> 15, factor);\n            const r = rx + ((ry & 0x7FFF) << 15) + high + carry;\n            carry = r >>> 30;\n            high = ry >>> 15;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (result.length > n) {\n            result.__setDigit(n++, carry + high);\n            while (n < result.length) {\n                result.__setDigit(n++, 0);\n            }\n        }\n        else {\n            if (carry + high !== 0)\n                throw new Error('implementation bug');\n        }\n    }\n    __inplaceMultiplyAdd(multiplier, summand, length) {\n        if (length > this.length)\n            length = this.length;\n        const mLow = multiplier & 0x7FFF;\n        const mHigh = multiplier >>> 15;\n        let carry = 0;\n        let high = summand;\n        for (let i = 0; i < length; i++) {\n            const d = this.__digit(i);\n            const dLow = d & 0x7FFF;\n            const dHigh = d >>> 15;\n            const pLow = JSBI.__imul(dLow, mLow);\n            const pMid1 = JSBI.__imul(dLow, mHigh);\n            const pMid2 = JSBI.__imul(dHigh, mLow);\n            const pHigh = JSBI.__imul(dHigh, mHigh);\n            let result = high + pLow + carry;\n            carry = result >>> 30;\n            result &= 0x3FFFFFFF;\n            result += ((pMid1 & 0x7FFF) << 15) + ((pMid2 & 0x7FFF) << 15);\n            carry += result >>> 30;\n            high = pHigh + (pMid1 >>> 15) + (pMid2 >>> 15);\n            this.__setDigit(i, result & 0x3FFFFFFF);\n        }\n        if (carry !== 0 || high !== 0) {\n            throw new Error('implementation bug');\n        }\n    }\n    static __absoluteDivSmall(x, divisor, quotient = null) {\n        if (quotient === null)\n            quotient = new JSBI(x.length, false);\n        let remainder = 0;\n        for (let i = x.length * 2 - 1; i >= 0; i -= 2) {\n            let input = ((remainder << 15) | x.__halfDigit(i)) >>> 0;\n            const upperHalf = (input / divisor) | 0;\n            remainder = (input % divisor) | 0;\n            input = ((remainder << 15) | x.__halfDigit(i - 1)) >>> 0;\n            const lowerHalf = (input / divisor) | 0;\n            remainder = (input % divisor) | 0;\n            quotient.__setDigit(i >>> 1, (upperHalf << 15) | lowerHalf);\n        }\n        return quotient;\n    }\n    static __absoluteModSmall(x, divisor) {\n        let remainder = 0;\n        for (let i = x.length * 2 - 1; i >= 0; i--) {\n            const input = ((remainder << 15) | x.__halfDigit(i)) >>> 0;\n            remainder = (input % divisor) | 0;\n        }\n        return remainder;\n    }\n    static __absoluteDivLarge(dividend, divisor, wantQuotient, wantRemainder) {\n        const n = divisor.__halfDigitLength();\n        const n2 = divisor.length;\n        const m = dividend.__halfDigitLength() - n;\n        let q = null;\n        if (wantQuotient) {\n            q = new JSBI((m + 2) >>> 1, false);\n            q.__initializeDigits();\n        }\n        const qhatv = new JSBI((n + 2) >>> 1, false);\n        qhatv.__initializeDigits();\n        // D1.\n        const shift = JSBI.__clz15(divisor.__halfDigit(n - 1));\n        if (shift > 0) {\n            divisor = JSBI.__specialLeftShift(divisor, shift, 0 /* add no digits*/);\n        }\n        const u = JSBI.__specialLeftShift(dividend, shift, 1 /* add one digit */);\n        // D2.\n        const vn1 = divisor.__halfDigit(n - 1);\n        let halfDigitBuffer = 0;\n        for (let j = m; j >= 0; j--) {\n            // D3.\n            let qhat = 0x7FFF;\n            const ujn = u.__halfDigit(j + n);\n            if (ujn !== vn1) {\n                const input = ((ujn << 15) | u.__halfDigit(j + n - 1)) >>> 0;\n                qhat = (input / vn1) | 0;\n                let rhat = (input % vn1) | 0;\n                const vn2 = divisor.__halfDigit(n - 2);\n                const ujn2 = u.__halfDigit(j + n - 2);\n                while ((JSBI.__imul(qhat, vn2) >>> 0) > (((rhat << 16) | ujn2) >>> 0)) {\n                    qhat--;\n                    rhat += vn1;\n                    if (rhat > 0x7FFF)\n                        break;\n                }\n            }\n            // D4.\n            JSBI.__internalMultiplyAdd(divisor, qhat, 0, n2, qhatv);\n            let c = u.__inplaceSub(qhatv, j, n + 1);\n            if (c !== 0) {\n                c = u.__inplaceAdd(divisor, j, n);\n                u.__setHalfDigit(j + n, (u.__halfDigit(j + n) + c) & 0x7FFF);\n                qhat--;\n            }\n            if (wantQuotient) {\n                if (j & 1) {\n                    halfDigitBuffer = qhat << 15;\n                }\n                else {\n                    // TODO make this statically determinable\n                    q.__setDigit(j >>> 1, halfDigitBuffer | qhat);\n                }\n            }\n        }\n        if (wantRemainder) {\n            u.__inplaceRightShift(shift);\n            if (wantQuotient) {\n                return { quotient: q, remainder: u };\n            }\n            return u;\n        }\n        if (wantQuotient)\n            return q;\n        // TODO find a way to make this statically unreachable?\n        throw new Error('unreachable');\n    }\n    static __clz15(value) {\n        return JSBI.__clz30(value) - 15;\n    }\n    // TODO: work on full digits, like __inplaceSub?\n    __inplaceAdd(summand, startIndex, halfDigits) {\n        let carry = 0;\n        for (let i = 0; i < halfDigits; i++) {\n            const sum = this.__halfDigit(startIndex + i) +\n                summand.__halfDigit(i) +\n                carry;\n            carry = sum >>> 15;\n            this.__setHalfDigit(startIndex + i, sum & 0x7FFF);\n        }\n        return carry;\n    }\n    __inplaceSub(subtrahend, startIndex, halfDigits) {\n        const fullSteps = (halfDigits - 1) >>> 1;\n        let borrow = 0;\n        if (startIndex & 1) {\n            // this:   [..][..][..]\n            // subtr.:   [..][..]\n            startIndex >>= 1;\n            let current = this.__digit(startIndex);\n            let r0 = current & 0x7FFF;\n            let i = 0;\n            for (; i < fullSteps; i++) {\n                const sub = subtrahend.__digit(i);\n                const r15 = (current >>> 15) - (sub & 0x7FFF) - borrow;\n                borrow = (r15 >>> 15) & 1;\n                this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n                current = this.__digit(startIndex + i + 1);\n                r0 = (current & 0x7FFF) - (sub >>> 15) - borrow;\n                borrow = (r0 >>> 15) & 1;\n            }\n            // Unrolling the last iteration gives a 5% performance benefit!\n            const sub = subtrahend.__digit(i);\n            const r15 = (current >>> 15) - (sub & 0x7FFF) - borrow;\n            borrow = (r15 >>> 15) & 1;\n            this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n            const subTop = sub >>> 15;\n            if (startIndex + i + 1 >= this.length) {\n                throw new RangeError('out of bounds');\n            }\n            if ((halfDigits & 1) === 0) {\n                current = this.__digit(startIndex + i + 1);\n                r0 = (current & 0x7FFF) - subTop - borrow;\n                borrow = (r0 >>> 15) & 1;\n                this.__setDigit(startIndex + subtrahend.length, (current & 0x3FFF8000) | (r0 & 0x7FFF));\n            }\n        }\n        else {\n            startIndex >>= 1;\n            let i = 0;\n            for (; i < subtrahend.length - 1; i++) {\n                const current = this.__digit(startIndex + i);\n                const sub = subtrahend.__digit(i);\n                const r0 = (current & 0x7FFF) - (sub & 0x7FFF) - borrow;\n                borrow = (r0 >>> 15) & 1;\n                const r15 = (current >>> 15) - (sub >>> 15) - borrow;\n                borrow = (r15 >>> 15) & 1;\n                this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n            }\n            const current = this.__digit(startIndex + i);\n            const sub = subtrahend.__digit(i);\n            const r0 = (current & 0x7FFF) - (sub & 0x7FFF) - borrow;\n            borrow = (r0 >>> 15) & 1;\n            let r15 = 0;\n            if ((halfDigits & 1) === 0) {\n                r15 = (current >>> 15) - (sub >>> 15) - borrow;\n                borrow = (r15 >>> 15) & 1;\n            }\n            this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n        }\n        return borrow;\n    }\n    __inplaceRightShift(shift) {\n        if (shift === 0)\n            return;\n        let carry = this.__digit(0) >>> shift;\n        const last = this.length - 1;\n        for (let i = 0; i < last; i++) {\n            const d = this.__digit(i + 1);\n            this.__setDigit(i, ((d << (30 - shift)) & 0x3FFFFFFF) | carry);\n            carry = d >>> shift;\n        }\n        this.__setDigit(last, carry);\n    }\n    static __specialLeftShift(x, shift, addDigit) {\n        const n = x.length;\n        const resultLength = n + addDigit;\n        const result = new JSBI(resultLength, false);\n        if (shift === 0) {\n            for (let i = 0; i < n; i++)\n                result.__setDigit(i, x.__digit(i));\n            if (addDigit > 0)\n                result.__setDigit(n, 0);\n            return result;\n        }\n        let carry = 0;\n        for (let i = 0; i < n; i++) {\n            const d = x.__digit(i);\n            result.__setDigit(i, ((d << shift) & 0x3FFFFFFF) | carry);\n            carry = d >>> (30 - shift);\n        }\n        if (addDigit > 0) {\n            result.__setDigit(n, carry);\n        }\n        return result;\n    }\n    static __leftShiftByAbsolute(x, y) {\n        const shift = JSBI.__toShiftAmount(y);\n        if (shift < 0)\n            throw new RangeError('BigInt too big');\n        const digitShift = (shift / 30) | 0;\n        const bitsShift = shift % 30;\n        const length = x.length;\n        const grow = bitsShift !== 0 &&\n            (x.__digit(length - 1) >>> (30 - bitsShift)) !== 0;\n        const resultLength = length + digitShift + (grow ? 1 : 0);\n        const result = new JSBI(resultLength, x.sign);\n        if (bitsShift === 0) {\n            let i = 0;\n            for (; i < digitShift; i++)\n                result.__setDigit(i, 0);\n            for (; i < resultLength; i++) {\n                result.__setDigit(i, x.__digit(i - digitShift));\n            }\n        }\n        else {\n            let carry = 0;\n            for (let i = 0; i < digitShift; i++)\n                result.__setDigit(i, 0);\n            for (let i = 0; i < length; i++) {\n                const d = x.__digit(i);\n                result.__setDigit(i + digitShift, ((d << bitsShift) & 0x3FFFFFFF) | carry);\n                carry = d >>> (30 - bitsShift);\n            }\n            if (grow) {\n                result.__setDigit(length + digitShift, carry);\n            }\n            else {\n                if (carry !== 0)\n                    throw new Error('implementation bug');\n            }\n        }\n        return result.__trim();\n    }\n    static __rightShiftByAbsolute(x, y) {\n        const length = x.length;\n        const sign = x.sign;\n        const shift = JSBI.__toShiftAmount(y);\n        if (shift < 0)\n            return JSBI.__rightShiftByMaximum(sign);\n        const digitShift = (shift / 30) | 0;\n        const bitsShift = shift % 30;\n        let resultLength = length - digitShift;\n        if (resultLength <= 0)\n            return JSBI.__rightShiftByMaximum(sign);\n        // For negative numbers, round down if any bit was shifted out (so that\n        // e.g. -5n >> 1n == -3n and not -2n). Check now whether this will happen\n        // and whether itc an cause overflow into a new digit. If we allocate the\n        // result large enough up front, it avoids having to do grow it later.\n        let mustRoundDown = false;\n        if (sign) {\n            const mask = (1 << bitsShift) - 1;\n            if ((x.__digit(digitShift) & mask) !== 0) {\n                mustRoundDown = true;\n            }\n            else {\n                for (let i = 0; i < digitShift; i++) {\n                    if (x.__digit(i) !== 0) {\n                        mustRoundDown = true;\n                        break;\n                    }\n                }\n            }\n        }\n        // If bitsShift is non-zero, it frees up bits, preventing overflow.\n        if (mustRoundDown && bitsShift === 0) {\n            // Overflow cannot happen if the most significant digit has unset bits.\n            const msd = x.__digit(length - 1);\n            const roundingCanOverflow = ~msd === 0;\n            if (roundingCanOverflow)\n                resultLength++;\n        }\n        let result = new JSBI(resultLength, sign);\n        if (bitsShift === 0) {\n            // Zero out any overflow digit (see \"roundingCanOverflow\" above).\n            result.__setDigit(resultLength - 1, 0);\n            for (let i = digitShift; i < length; i++) {\n                result.__setDigit(i - digitShift, x.__digit(i));\n            }\n        }\n        else {\n            let carry = x.__digit(digitShift) >>> bitsShift;\n            const last = length - digitShift - 1;\n            for (let i = 0; i < last; i++) {\n                const d = x.__digit(i + digitShift + 1);\n                result.__setDigit(i, ((d << (30 - bitsShift)) & 0x3FFFFFFF) | carry);\n                carry = d >>> bitsShift;\n            }\n            result.__setDigit(last, carry);\n        }\n        if (mustRoundDown) {\n            // Since the result is negative, rounding down means adding one to its\n            // absolute value. This cannot overflow.\n            result = JSBI.__absoluteAddOne(result, true, result);\n        }\n        return result.__trim();\n    }\n    static __rightShiftByMaximum(sign) {\n        if (sign) {\n            return JSBI.__oneDigit(1, true);\n        }\n        return JSBI.__zero();\n    }\n    static __toShiftAmount(x) {\n        if (x.length > 1)\n            return -1;\n        const value = x.__unsignedDigit(0);\n        if (value > JSBI.__kMaxLengthBits)\n            return -1;\n        return value;\n    }\n    static __toPrimitive(obj, hint = 'default') {\n        if (typeof obj !== 'object')\n            return obj;\n        if (obj.constructor === JSBI)\n            return obj;\n        if (typeof Symbol !== 'undefined' &&\n            typeof Symbol.toPrimitive === 'symbol') {\n            if (obj[Symbol.toPrimitive]) {\n                const primitive = obj[Symbol.toPrimitive](hint);\n                if (typeof primitive !== 'object')\n                    return primitive;\n                throw new TypeError('Cannot convert object to primitive value');\n            }\n        }\n        const valueOf = obj.valueOf;\n        if (valueOf) {\n            const primitive = valueOf.call(obj);\n            if (typeof primitive !== 'object')\n                return primitive;\n        }\n        const toString = obj.toString;\n        if (toString) {\n            const primitive = toString.call(obj);\n            if (typeof primitive !== 'object')\n                return primitive;\n        }\n        throw new TypeError('Cannot convert object to primitive value');\n    }\n    static __toNumeric(value) {\n        if (JSBI.__isBigInt(value))\n            return value;\n        return +value;\n    }\n    static __isBigInt(value) {\n        return typeof value === 'object' && value !== null &&\n            value.constructor === JSBI;\n    }\n    static __truncateToNBits(n, x) {\n        const neededDigits = ((n + 29) / 30) | 0;\n        const result = new JSBI(neededDigits, x.sign);\n        const last = neededDigits - 1;\n        for (let i = 0; i < last; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        let msd = x.__digit(last);\n        if ((n % 30) !== 0) {\n            const drop = 32 - (n % 30);\n            msd = (msd << drop) >>> drop;\n        }\n        result.__setDigit(last, msd);\n        return result.__trim();\n    }\n    static __truncateAndSubFromPowerOfTwo(n, x, resultSign) {\n        const neededDigits = ((n + 29) / 30) | 0;\n        const result = new JSBI(neededDigits, resultSign);\n        let i = 0;\n        const last = neededDigits - 1;\n        let borrow = 0;\n        const limit = Math.min(last, x.length);\n        for (; i < limit; i++) {\n            const r = 0 - x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < last; i++) {\n            result.__setDigit(i, (-borrow & 0x3FFFFFFF) | 0);\n        }\n        let msd = last < x.length ? x.__digit(last) : 0;\n        const msdBitsConsumed = n % 30;\n        let resultMsd;\n        if (msdBitsConsumed === 0) {\n            resultMsd = 0 - msd - borrow;\n            resultMsd &= 0x3FFFFFFF;\n        }\n        else {\n            const drop = 32 - msdBitsConsumed;\n            msd = (msd << drop) >>> drop;\n            const minuendMsd = 1 << (32 - drop);\n            resultMsd = minuendMsd - msd - borrow;\n            resultMsd &= (minuendMsd - 1);\n        }\n        result.__setDigit(last, resultMsd);\n        return result.__trim();\n    }\n    // Digit helpers.\n    __digit(i) {\n        return this[i];\n    }\n    __unsignedDigit(i) {\n        return this[i] >>> 0;\n    }\n    __setDigit(i, digit) {\n        this[i] = digit | 0;\n    }\n    __setDigitGrow(i, digit) {\n        this[i] = digit | 0;\n    }\n    __halfDigitLength() {\n        const len = this.length;\n        if (this.__unsignedDigit(len - 1) <= 0x7FFF)\n            return len * 2 - 1;\n        return len * 2;\n    }\n    __halfDigit(i) {\n        return (this[i >>> 1] >>> ((i & 1) * 15)) & 0x7FFF;\n    }\n    __setHalfDigit(i, value) {\n        const digitIndex = i >>> 1;\n        const previous = this.__digit(digitIndex);\n        const updated = (i & 1) ? (previous & 0x7FFF) | (value << 15) :\n            (previous & 0x3FFF8000) | (value & 0x7FFF);\n        this.__setDigit(digitIndex, updated);\n    }\n    static __digitPow(base, exponent) {\n        let result = 1;\n        while (exponent > 0) {\n            if (exponent & 1)\n                result *= base;\n            exponent >>>= 1;\n            base *= base;\n        }\n        return result;\n    }\n    static __detectBigEndian() {\n        JSBI.__kBitConversionDouble[0] = -0.0;\n        return JSBI.__kBitConversionInts[0] !== 0;\n    }\n    static __isOneDigitInt(x) {\n        return (x & 0x3FFFFFFF) === x;\n    }\n}\nJSBI.__kMaxLength = 1 << 25;\nJSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5;\n// Lookup table for the maximum number of bits required per character of a\n// base-N string representation of a number. To increase accuracy, the array\n// value is the actual value multiplied by 32. To generate this table:\n//\n// for (let i = 0; i <= 36; i++) {\n//   console.log(Math.ceil(Math.log2(i) * 32) + ',');\n// }\nJSBI.__kMaxBitsPerChar = [\n    0, 0, 32, 51, 64, 75, 83, 90, 96,\n    102, 107, 111, 115, 119, 122, 126, 128,\n    131, 134, 136, 139, 141, 143, 145, 147,\n    149, 151, 153, 154, 156, 158, 159, 160,\n    162, 163, 165, 166, // 33..36\n];\nJSBI.__kBitsPerCharTableShift = 5;\nJSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift;\nJSBI.__kConversionChars = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');\nJSBI.__kBitConversionBuffer = new ArrayBuffer(8);\nJSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer);\nJSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer);\nJSBI.__kBitConversionIntHigh = JSBI.__detectBigEndian() ? 0 : 1;\nJSBI.__kBitConversionIntLow = JSBI.__detectBigEndian() ? 1 : 0;\n// For IE11 compatibility.\n// Note that the custom replacements are tailored for JSBI's needs, and as\n// such are not reusable as general-purpose polyfills.\nJSBI.__clz30 = Math.clz32 ? function (x) {\n    return Math.clz32(x) - 2;\n} : function (x) {\n    if (x === 0)\n        return 30;\n    return 29 - (Math.log(x >>> 0) / Math.LN2 | 0) | 0;\n};\nJSBI.__imul = Math.imul || function (a, b) {\n    return (a * b) | 0;\n};\nexport default JSBI;\n//# sourceMappingURL=jsbi.js.map"],
  "mappings": "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",
  "names": ["JSBI", "Array", "constructor", "length", "sign", "Object", "setPrototypeOf", "prototype", "__kMaxLength", "RangeError", "BigInt", "arg", "_", "Math", "floor", "t", "Number", "isFinite", "__zero", "__isOneDigitInt", "__oneDigit", "__fromDouble", "result", "__fromString", "SyntaxError", "primitive", "__toPrimitive", "TypeError", "toDebugString", "digit", "push", "toString", "join", "radix", "__toStringBasePowerOfTwo", "__toStringGeneric", "valueOf", "Error", "toNumber", "x", "xLength", "value", "__unsignedDigit", "xMsd", "__digit", "msdLeadingZeros", "__clz30", "xBitLength", "exponent", "currentDigit", "digitIndex", "shift", "mantissaHigh", "mantissaHighBitsUnset", "mantissaLow", "mantissaLowBitsUnset", "rounding", "__decideRounding", "signBit", "__kBitConversionInts", "__kBitConversionIntHigh", "__kBitConversionIntLow", "__kBitConversionDouble", "unaryMinus", "__copy", "bitwiseNot", "__absoluteSubOne", "__trim", "__absoluteAddOne", "exponentiate", "y", "expValue", "__kMaxLengthBits", "neededDigits", "__initializeDigits", "msd", "__setDigit", "runningSquare", "multiply", "resultLength", "__clzmsd", "i", "__multiplyAccumulate", "divide", "__absoluteCompare", "resultSign", "divisor", "quotient", "__absoluteDivSmall", "__absoluteDivLarge", "remainder", "remainderDigit", "__absoluteModSmall", "add", "__absoluteAdd", "__absoluteSub", "subtract", "leftShift", "__rightShiftByAbsolute", "__leftShiftByAbsolute", "signedRightShift", "unsignedRightShift", "lessThan", "__compareToBigInt", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "equal", "notEqual", "bitwiseAnd", "max", "__absoluteAnd", "y1", "__absoluteOr", "__absoluteAndNot", "bitwiseXor", "__absoluteXor", "bitwiseOr", "asIntN", "n", "neededLength", "topDigit", "compareDigit", "__truncateToNBits", "__truncateAndSubFromPowerOfTwo", "asUintN", "bitsInTopDigit", "ADD", "__toNumeric", "__isBigInt", "LT", "__compare", "LE", "GT", "GE", "EQ", "__equalToNumber", "NE", "DataViewGetBigInt64", "dataview", "byteOffset", "littleEndian", "DataViewGetBigUint64", "h", "l", "high", "getUint32", "low", "DataViewSetBigInt64", "DataViewSetBigUint64", "d1", "setUint32", "newLength", "last", "pop", "mantissaBitsUnset", "topUnconsumedBit", "mask", "rawExponent", "digits", "kMantissaHighTopBit", "msdTopBit", "remainingMantissaBits", "__isWhitespace", "c", "string", "cursor", "current", "charCodeAt", "chars", "bitsPerChar", "__kMaxBitsPerChar", "roundup", "__kBitsPerCharTableMultiplier", "bitsMin", "__kBitsPerCharTableShift", "limDigit", "limAlpha", "parts", "partsBits", "done", "part", "bits", "d", "__fillFromParts", "charsSoFar", "multiplier", "m", "digitsSoFar", "__inplaceMultiplyAdd", "bitsInDigit", "partBits", "charMask", "charsRequired", "pos", "availableBits", "newDigit", "__kConversionChars", "consumedBits", "isRecursiveCall", "bitLength", "maxBitsPerChar", "minBitsPerChar", "secondHalfChars", "conqueror", "secondHalf", "input", "__halfDigit", "__setHalfDigit", "divisionResult", "firstHalf", "__unequalSign", "leftNegative", "__absoluteGreater", "bothNegative", "__absoluteLess", "xSign", "__compareToNumber", "ySign", "yAbs", "abs", "xDigit", "__compareToDouble", "yBitLength", "compareMantissa", "__comparisonResultToBool", "op", "carry", "r", "borrow", "inputLength", "__setDigitGrow", "yLength", "numPairs", "tmp", "tmpLength", "diff", "multiplicand", "accumulator", "accumulatorIndex", "m2Low", "m2High", "acc", "m1", "m1Low", "m1High", "rLow", "__imul", "rMid1", "rMid2", "rHigh", "__internalMultiplyAdd", "source", "factor", "summand", "rx", "ry", "mLow", "mHigh", "dLow", "dHigh", "pLow", "pMid1", "pMid2", "pHigh", "upperHalf", "lowerHalf", "dividend", "wantQuotient", "wantRemainder", "__halfDigitLength", "n2", "q", "qhatv", "__clz15", "__specialLeftShift", "u", "vn1", "halfDigitBuffer", "qhat", "j", "ujn", "rhat", "vn2", "ujn2", "__inplaceSub", "__inplaceAdd", "__inplaceRightShift", "startIndex", "halfDigits", "sum", "subtrahend", "r0", "sub", "r15", "addDigit", "__toShiftAmount", "digitShift", "bitsShift", "grow", "__rightShiftByMaximum", "mustRoundDown", "obj", "hint", "Symbol", "toPrimitive", "call", "drop", "min", "limit", "msdBitsConsumed", "resultMsd", "minuendMsd", "len", "previous", "updated", "__digitPow", "base", "__detectBigEndian", "__kBitConversionBuffer", "ArrayBuffer", "Float64Array", "Int32Array", "clz32", "log", "LN2", "imul", "a", "b"]
}
